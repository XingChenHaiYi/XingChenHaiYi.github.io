//指针  保存地址的变量；
//int i
//int* p = &i;  *意为p是指针  指向一个Int  然后把i的地址交给P 
// 如果i放在  ix2000的地方  则p = 2000 p的值是i的地址 称为・p指向i; 
// int* p,q   int *p,q 意思相同  p是个指针，指向int ,而 q是一个int 变量   
//即我们是把*交给p  而不是int


 
//指针变量 的值是内存的地址  普通变量的值是实际的值
//指针变量的值是举要实际值的变量的地址 



# include <stdio.h>

void f(int *p)
{
//当把一个・指针・作为参数时  可以这么写  void f(int*p)  即f函数要一个int的指针 
//调用f函数时  要交给它一个变量的地址而不是值  int i=0; f(&i); 

	printf("p=%p\n",p);// %p为调用地址 
	printf("*p=%d\n",*p);// *p是输入的那个数意为用 *访问地址p上的变量 
	*p = 26;
//	把p地址上表示的6改26,用g函数输出i;    i变成了26; 

//  我们一直认为  函数调用时发生参数的转移  是一种值的传递 ； 在函数里 函数的参数与调用它的地方没有任何联系 
//  此时我们仍然坚持  此时发生的是值的传递  此时
//  i的地址值被传递进了函数  但是因为传递的是地址，在函数内部 我们依旧可以用它访问到外面i这个变量 并修改它 
	
//在函数里，可以 通过这个指针访问外面的i； 
//*是一个单目运算符，用来访问指针的值所表示的地址上的变量； 
//可以做右值也可以做左值 
//int k = *p;    p = k+1;
//

//左值之所以叫左值  是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果；
// 如 a[0]=2; *p = 3;  []和*都是运算符 a[0]和*p都是运算结果，可以作左值；
// 是特殊的值 所以叫左值；

//  指针的运算符&*  一个是取地址  一个是取得地址上的变量；   互相反作用  *&a=&*a =a;
}

void g(int k)
{
	printf("k = %d\n",k);
}
int main()
{
	int i = 6;
	printf("&i=%p\n",&i);
	f(&i);
	g(i);
	return 0;
}
