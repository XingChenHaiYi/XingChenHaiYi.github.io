#include <stdio.h>
//在一组给定的数据中，如何找出某个数据是否存在 

/**
找出key在数组a中的位置
@param key 要寻找的数字
@param a 要寻找的数组
@param length 数组a的长度
@return 如果找到，返回其在a中的位置；如果找不到则返回-1
*/
int search(int key,int a[],int length);

int main(void)
{//直接用大括号给出数组的所有元素初始值  不需要给出数组大小，编译器替你数 
	int a[] = {2,4,6,7,1,3,5,9,11,13,23,14,32,};//数组的集成初始化，用这一组数字初始化a这个数组 
	{//如果中括号里写13，大括号写2，则会有1个2和12个0
	//如果 int a[13] = {【1】=2,4,[5]=6} 则a [1] = 2,a[2] = 4,a[5] = 6,其余0 
	
	//                   集成初始化时的定位   
	//只有c99有用 
	//  用[n]在初始化数据中给出定位 
	//没有定位的数据接在前面的位置后面
	//其他位置的值补零 
	// 也可以不给出数组大小，让编译器算 
	//特别适合初始数据稀疏的数组 
	// int a[10] = {[0] = 2,[2] = 3,6,}}
	//按照传统在后面留逗号，不会影响，且便利于添加新数字 
	//即a[0]=2 ，a[2] = 3 ,a[3]=6,其他都为0
	 
	//              数组的大小       
	//    sizeof 是一个运算符 可以告诉我们这个变量/类型有多大，可以给出数组占据的字节 
	//
	//
	//
	//
		int i;
		printf("%lu\n",sizeof(a));  //52  52个字节   52/4 = 13  每个int单元4字节 
		for(i=0;i<13;i++){//所以可以改成for(i=0;i<sizeof(a)/sizeof(a[0]);i++)使其更安全 
			printf("%d\t",a[i]);
			//  sizeof(a)/sizeof(a[0])
			// sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数 
			//这样的代码，一旦我们修改数组中的初始数据，不需要修改遍历的代码 
		}//遍历a的数组 
		printf("\n");
	}
	int x;
	int loc;
	printf("请输入一个数字");
	scanf("%d",&x);
	int c,d;
	loc = search(x,a,sizeof(a)/4);
	if (loc !=-1){
	printf("%d在第%d个位置上\n",x,loc);
	} else {
	    printf("%d不存在\n",x);
	}
	return 0;
} 

int search(int key,int a[],int length)
{
	int ret = -1;
	int i;
	for(i=0;i<length;i++){
		if(a[i]==key){
			ret = 1;
			break;
		}
		//此处遍历数组去判断 我们要找到东西是否存在 
	}
	return ret;
}
//数组的赋值
//不能用int b[] = a,因为不能用一个数组变量赋给另一个数组变量，因为数组变量是特殊的 
//要把一个数组的所有元素交给另一个数组，必须采用遍历  ,这是唯一方法。 
//  for(i=0;i<length;i++){
//      b[i] = a[i];
// }


//遍历数组
//通常是使用for循环，让循环变量i从0到<数组的长度，这样循环体内最大的i 正好是数组最大的有效下标 
//常见错误是： 
//循环结束条件是<=数组长度，或； 
//离开循环后，继续用i的值来做数组元素下标 

//数组作为函数时，往往必须再用另一个参数来传入数组的大小 
//数组作为函数的参数时：
//不能在[]中给出数组的大小
//不能再利用sizeof来计算数组的元素个数 
